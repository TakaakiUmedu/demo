<!DOCTYPE HTML>
<html lang="ja">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="layout-default2.css"></link>
<link rel="stylesheet" href="color-default2.css"></link>
<link rel="stylesheet" href="hamming.css"></link>
<title>ハミング符号デモ</title>
<script src="hamming.js"></script>
</head>
<body>

<h1>ハミング符号デモ</h1>

<div>
<ul>
<li>下記のMを書き換えて<q>Mを変更</q>をクリックすると、そのMに対して表が再構築される。</li>
<li>パリティMビットに対して、<code>2<sup>M</sup>-M-1</code>ビットのデータを送れる。</li>
<li>Mが大きくなるほど、<q>ペイロード(送れるデータの量)</q> / <q>ハミング符号付きデータの長さ</q>が大きくなり、効率が良くなるが、エラーに対して弱くなる。
  <ul>
  <li>M=1の場合、意味のあるデータを送れないので無意味。</li>
  <li>M=2の場合、送ったデータの内の1/3が壊れても訂正できるが、データを送るのに利用できるのはその内の1ビットだけ(3回送って多数決で<q>正解</q>を決めるやり方と同様)。</li>
  <li>M=3の場合、送ったデータの内の1/7が壊れても訂正できるが、データを送るのに利用できるのはその内の4ビットだけ。壊れなかった場合は、半分ぐらいは余分なデータを送ることになる。</li>
  <li>M=5の場合、31ビット中の26ビットをデータを送るのに使える(約84%の効率)。ただし、送ったデータの内の1/31まで壊れても訂正できるが、それより多く壊れると訂正できなくなる。</li>
  </ul>
</li>
<li>M=3か4ぐらいが見やすい。あまり大きな数を入れるとブラウザが固まるので注意。M=5ぐらいまでが、ブラウザで閲覧出来る限界。</li>
</ul>
<p><code>M = </code><input type="text" id="M" value="4"></input><input type="button" id="RESET" value="Mを変更"></input></p>
<div id="source">
<h5>送りたいデータ</h5>

<div id="source_table_holder"></div>
<ul>
<li><q>元データ</q>の行に送りたいデータを入力する(注意: 手抜きのため<q>0</q>以外を入力すると<q>1</q>と解釈されるようプログラムしてある)</li>
<li>送信側は、下記計算手順に従って、<q>元データ</q>から、<q>ハミング符号付きデータ</q>を準備して、送信する</li>
</ul>

</div>
<div id="table">
<h5>表を作る</h5>
<ul>
  <li>表の各列のタイトルは、1～2<sup>M</sup>-1とする。2進数表記も併記しておく</li>
  <li>表の列の内、各k (0 &lt; k ≦ M)に対して、2<sup>k</sup>を、それぞれ<q>パリティ M - k</q>の列とする。ここでは青い枠で示す</li>
  <li>残りの、2<sup>M</sup> - 1 - M列を、左から順番号を振って、データの列とする。ここでは水色の枠で示す</li>
  <li>送りたいデータを表にセットする</li>
</ul>
</div>

<div id="mask">
<h5>マスクを作る</h5>
<ul>
  <li>M個のマスクを作る</li>
  <li>k枚目のマスクは、右からkビット目が1のところだけをくりぬく</li>
  <li>それぞれのマスクから見える部分に、1が偶数個あるよう、青枠の空欄を埋める</li>
</ul>
</div>

<div id="ready">
<h5>送るデータの準備が完了(上の表の再掲)</h5>
<div id="ready_table"></div>
<p style="text-align:center;">↓ 送信する ↓</p>
</div>

<div id="error"></div>

<div id="received">
<p style="text-align:center;">↓ チェックを入れたビットの0/1が入れ替わってデータが壊れてしまったとする ↓</p>
<div id="received_table_holder">

</div>

</div>


<div id="result">
<h5>エラー訂正結果</h5>

<div id="result_table_holder"></div>
<ul id="result_ul"></ul>

</div>

<div id="circles"></div>



</div>

<div id="appendix1">
<h5>なぜこの方法で上手く行くのか?</h5>
<ul>
<li>送信側
	<ul>
	<li>それぞれのマスクの穴からは、パリティを書き込むための青い枠の空欄が、それぞれ1つずつ見える
	 <ul>
	  <li>それぞれのマスクは、2進数表記にしたときのある1桁が<q>1</q>であるような所に穴が開いている</li>
	  <li>青い枠は、どれか1桁だけが<q>1</q>で他が<q>0</q>であるような所に置かれている</li>
	 </ul>
	</li>
	<li>そのため、それぞれのマスクについて、1カ所の青いパリティ枠を埋める事で、穴から見えている<q>1</q>の個数を偶数個になるよう、かならず調整できる</li>
	</ul>
</li>
<li>受信側
	<ul>
	<li>1ビットだけ誤りがある場合、マスク k の穴の開き方から、あるマスクから見える<q>1</q>の個数が偶数か奇数かによって、2進数表記の左から k ビット目が確定する
	 <ul>
	  <li>マスク k から見える個数が奇数なら → その見えている内のどれかが間違っている → kビット目が<q>1</q>になるどれか間違っている</li>
	  <li>マスク k から見える個数が偶数なら → 見えていないどれかが間違っている → kビット目が<q>0</q>になるどれかが間違っている</li>
	 </ul>
	</li>
	<li>マスクは、M枚あるので、誤りのある番号の2進数表記の、Mビット分が確定する。すなわち、何番目のデータが間違っているかが確定する</li>
	</ul>
</li>
</ul>

</div>


<div id="appendix2">
<h5>数学的な説明</h5>
<p>原理のより詳細な数学的な説明は、<a href="http://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%9F%E3%83%B3%E3%82%B0%E7%AC%A6%E5%8F%B7">ハミング符号(Wikipedia)</a>や、他、教科書などを参照。
</p>
<p>
上記と同様の処理を行列を使って行う場合の計算手順を下記に示す。ただし、以下、加算は、排他的論理和(0 ⊕ 0 = 1 ⊕ 1 = 0、0 ⊕ 1 = 1 ⊕ 0 = 1とする演算<q>⊕</q>。足し算した後、2で割った余りをその答えとすると考えても良い)で行う。
まず、<code>1</code>～<code>2<sup>M</sup></code>の数値を2進数にしたものを上から順に並べたような<code>2<sup>M</sup></code>行<code>M</code>列の行列<code>H<sup>T</sup></code>を作る。
ただしこれは、Wikipediaで例示されている、<q>組織符号</q>と呼ばれるパターンとは異なる形にしてあることに注意。
上記の例に合わせるため、行列の並び順を変えてある。
</p>
<p>
次に、<code>H<sup>T</sup></code>の転置行列<code>H</code>を<q>検査行列H</q>とする。Hから<q>生成行列G</q>を求める。
生成行列Gとは、条件<code>H&times;G<sup>T</sup> = G&times;H<sup>T</sup>=0</code> を満たすような行列である。
ここでは生成行列Gは、Hを一旦、組織符号になるように並び替えたH'を作成し、H'それに対する生成行列G'を求め、G'をHに合わせて並び替え直すような方法で作っている。
</p>

<div class="math" id="math1">
</div>

<p>
このように作ると、誤り訂正時に行う、<q>受信データと検査行列Hの積で得られるパターンを転置したものと同じパターンが検査行列Hの何列目に当たるかを探す(受信データのその列にエラーがある)</q>という作業が、
<q>…得られるパターンを2進数と見なした数列目にエラーがある</q>と単純化出来る(Hを、パターン=<q>列数を2進数に直したもの</q>、となるように作ったため)。
また、0/1の並びに規則性が生じるメリットもある。
一方で、このように作ると、<q>ハミング符号付きデータ</q>中に、エラー訂正用のビットとデータのビットが混ざってややこしくなる。
組織符号の場合は、<q>ハミング符号付きデータ</q>が、元データの後ろにMビット分のエラー訂正用のビットをくっつけた形になって分かりやすい。
</p>

<p>
送信データ<code>x</code>、エラーベクトル<code>e</code>を、上記の表の値から下記の通りとすると、
ハミング符号付きデータ(送信データ)<code>Y</code>、エラーを反映した受信データ<code>Y'</code>、検査結果<code>r</code>はそれぞれ、以下のようになる。
</p>

<div class="math" id="math2">
</div>

<p>
またここで、rの定義より、
</p>
<div class="math">
r =  (Y ⊕ e) H<sup>T</sup><br/>
&nbsp;&nbsp; = (Y × H<sup>T</sup>) ⊕ (e × H<sup>T</sup>)<br/>
&nbsp;&nbsp; = (x × G × H<sup>T</sup>) ⊕ (e × H<sup>T</sup>)<br/>
&nbsp;&nbsp; = (x × 0) ⊕ (e × H<sup>T</sup>)<br/>
&nbsp;&nbsp; = 0 ⊕ (e × H<sup>T</sup>)<br/>
&nbsp;&nbsp; = e × H<sup>T</sup>
</div>

<p>
となるため、<code>e</code>が全て0(エラー無し)の場合は、<code>r</code>も全て0となる。
<code>e</code>がどこか1ビットのみ1で残りが0であるようなベクトル(エラーが1ビットだけ)の場合、<code>r = e &times; H<sup>T</sup></code>は、<code>H<sup>T</sup></code>から、
その1になっている1ビットに対応する行を取り出す計算になる。
つまり、このようにして求めた<code>r</code>から、どの列にエラーがあったかが分かる。
</p>

</div>

<div style="height: 5em;"></div>

</body>
</html>
